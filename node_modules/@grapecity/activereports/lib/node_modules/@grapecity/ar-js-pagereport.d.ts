/** @module Core */ /** */
import * as Rdl from "./ar-js-rdl";
import { i18n, WithT } from "i18next";
import { VNode } from "virtual-dom";
/**
 * Definition of apply parameter step.
 */
declare type ApplyParameterStep = SetParameterStep | ToggleParameterStep | ResetParameterStep;
/** @hidden */
declare const arjsStyles: string;
/** Provides data for language and culture specific text formatting. */
declare const CultureInfo: {
    /**
     * Registers culture.
     * @param identifier Locale (language) identifier, i.e. 'en-US', 'zh-CN', 'ru-RU'.
     * @param data @see LocaleData specific for locale.
     */
    registerCulture(identifier: string, data: LocaleData): void;
};
/**
 * Provides tool for registering user defined functions.
 */
declare const CustomCode: {
    /**
     * Register user defined function which can be used in Report through {Code.<functionName>()}.
     * @param functions Array with user defined functions.
     *
     * ```javascript
     * var functions = [
     *   {
     *     name: 'leftPad',
     *     body: (value, length, character) => length > value.length ? character.repeat(length - value.length) + value : value,
     *     info: {
     *       description: 'Adds number of characters before value to adjust it to specified length.',
     *       example: 'Code.leftPad("hello", 16, " ")',
     *       syntax: 'Code.leftPad(<String>, <Int64>, <String>)'
     *     }
     *   }
     * ];
     *
     * CustomCode.registerFunctions(functions);
     * ```
     */
    registerFunctions: (functions: UserDefinedFunction[]) => void;
    /**
     * Gets the list of registered user defined functions.
     */
    getFunctions: () => UserDefinedFunction[];
};
interface DataArray extends Array<DataValue> {
}
/** @hidden */
declare type DataDocumentMapFn = () => {
    kids: DocumentMapNode[];
};
declare type DataFieldsRecords = {
    descriptors: Array<{
        Name: string;
        Type: VariantType | null;
    }>;
    records: IterableIterator<DataValue[]>;
};
interface DataObject {
    [key: string]: DataValue;
}
interface DataResourceProvider<TDataId, TError> {
    getData(dataInfo: TDataId): Promise<Result<string, TError>>;
    getDataSync(dataInfo: TDataId): Result<string, TError>;
}
declare type DataValue = boolean | number | string | null | DataArray | DataObject | undefined | Date;
/** Date or time pattern identifier. */
declare type DateFormatKey = "Short date" | "Long date" | "Month/day" | "Short time" | "Long time" | "Year/month";
//# sourceMappingURL=dateTimeFunctions.d.ts.map
/** Language specific data and time format data. */
declare type DateTimeFormatInfo = {
    /** Ordered names of months starting from January.  */
    months: string[];
    /** Ordered declined names of months starting from January. */
    monthsDeclined?: string[];
    /** Ordered short names of months starting from January. */
    monthsShort: string[];
    /** Ordered names of week days starting from Sunday. */
    days: string[];
    /** Ordered short names of week days starting from Sunday. */
    daysShort: string[];
    /** Ordered identifiers of quarters starting from Sunday. */
    quarters: string[];
    /** Day period ('AM' or 'PM') names. */
    amPm: string[];
    /** Day period ('AM' or 'PM') short names. */
    amPmShort: string[];
    /** Current era name. */
    era: string;
};
declare type DocumentMapNode = {
    anchor: string;
    name: string | null;
    level: number;
    kids: DocumentMapNode[];
    isLeaf: boolean;
    page: number | null;
};
declare type DOMRenderingOptions = {
    /**
     * Specify elements ids to add 'searchHighlight' class
     */
    searchResults?: SearchResult[];
    /**
     * Provide Document instance for creatineg elements (window.document if undefined)
     */
    targetDocument?: Document;
    /**
     * Hide or show toggle and sort icons
     */
    hideInteractivity?: boolean;
};
/**
 * Report environment used for expressions calculation.
 */
declare type Environment = {
    /** Report name */
    readonly ReportName?: string;
    /** Report directory name */
    readonly ReportFolder?: string;
};
/**
 * Event listener
 * @typeparam TArgs event argument type
 */
interface Event<TArgs> {
    /**
     * Registers a new event handler.
     * @param eventHandler
     */
    register(eventHandler: EventHandler<TArgs>): UnregisterHandler;
}
/**
* Event Handler
* @typeparam TArgs event argument type
*/
declare type EventHandler<TArgs> = (args: TArgs) => void;
declare type ExprScopeSortState = {
    Expression: string;
    Direction: NonNullable<Rdl.SortExpression["Direction"]>;
};
declare type Failure<TErr> = {
    kind: "failure";
    error: TErr;
};
/** @module Core */ /** */
/**
 * Font file descriptor
 */
interface FontDescriptor {
    /** Font family name, e.g. "Segoe UI" */
    name: string;
    /** Font file URI, supported file formats are *.ttf, *.otf and *.woff */
    source: string | string[];
    /** Fallback fonts that will be searched on the local machine */
    locals?: string[];
    /** Font weight, e.g. "bold" */
    weight?: string;
    /** Font style, e.g. "italic" */
    style?: string;
    /** The font postscript name. */
    postscriptName?: string;
    /** True - to use the font as default font in PDF export. */
    useAsDefault?: boolean;
}
/**
 * Provides tools for registering fonts in CSS and pdf export.
 */
declare const FontStore: {
    /**
     * @param ...fonts List of FontDescriptor
     * Register specified fonts in CSS and pdf export. Helps display export correctly on machines where fonts can be missed.
     *
     * ```javascript
     * type FontDescriptor = {
     *     name: string,
     *     source: string,
     *     weight?: 'normal' | 'bold' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900',
     *     style?: 'normal' | 'italic' | 'oblique'
     * }
     *
     *
     * var arial = {
     *     name: 'Arial',
     *     source: 'fonts/arial.ttf',
     *     style: 'italic',
     *     weight: '700',
     * };
     *
     *
     * var gothic = {
     *     name: 'MS PGothic',
     *     source: 'fonts/MS-PGothic.ttf'
     * };
     *
     *
     * FontStore.registerFonts(arial);
     * //OR
     * FontStore.registerFonts(arial, gothic);
     * //OR
     * var fonts = [arial, gothic]; FontStore.registerFonts(...fonts);
     * ```
     *
     * @param configUri Path to fontsConfig.json file
     * Register fonts specified in —Åonfig file.
     * ```javascript
     * FontStore.registerFonts('./fontsConfig.json');
     * ```
     * @returns Promise<void>
     */
    registerFonts: ((...fonts: FontDescriptor[]) => Promise<void>) & ((configUri: string) => Promise<void>);
    /**
     * Get registered font descriptors.
     * @returns List of registered font descriptors.
     */
    getFonts: () => FontDescriptor[];
};
/** @hidden */
declare function getLicenseKey(): string;
declare type GetRequestInfo = {
    uri: string;
    method: "get";
    credentials?: "include";
    headers?: Record<string, string>;
};
declare type GetValuesResult = {
    [key: string]: {
        validValues: ParameterValue[];
        values: any[];
    };
};
declare type InteractiveState = {
    Toggles: ToggleAction[];
    SortState: SortState;
};
declare type Layout<T> = LFunc<LFunc<T>>;
declare type LayoutOrder = NonNullable<Rdl.Report["LayoutOrder"]>;
/**
 *  Layout function type. Given some space performs element layout and returns layout result of type TR.
 *
 * @template TR
 * @param size
 */
declare type LFunc<TR> = (size: number) => Result$1<TR>;
/** Culture specific data used for text formatting. */
declare type LocaleData = DateTimeFormatInfo & NumberFormatInfo & {
    /** Locale identifier. */
    name: string;
    /** Date, time and number patterns. */
    formats: Record<NumberFormatKey | DateFormatKey, string>;
};
declare type NodePatch = {
    id: string | null;
    style?: Object | null;
    children?: Array<VNode> | null;
    className?: string | null;
};
/** Special value to indicate that value is not set. */
declare const noValue: undefined;
/** Defines special value to indicate that value is not set. */
declare type NoValueType = typeof noValue;
/** Culture specific number format data. */
declare type NumberFormatInfo = {
    /** Thousands separator. */
    thousandSeparator: string;
    /** Decimal separator. */
    decimalSeparator: string;
};
/** Number pattern identifier. */
declare type NumberFormatKey = "Percent" | "Currency"; //# sourceMappingURL=localizedFormatter.d.ts.map
/** Represents rendered report. */
declare class PageDocument {
    private readonly report;
    private readonly i18n;
    /*@hidden */
    readonly styles: StaticStyle[];
    private static create;
    /** @hidden */
    readonly ctx: Environment;
    /** @hidden */
    readonly pageInfo: PageInfo | null;
    /** @hidden */
    readonly layoutOrder: LayoutOrder;
    /** @hidden */
    private sortState;
    private dataLayoutFn;
    private resultTree;
    private readonly data;
    private constructor();
    /** @hidden */
    getLayout(interactivityState: InteractiveState): Promise<{
        layout: RunLayout;
        documentMap: DataDocumentMapFn;
    }>;
    /** @hidden */
    runRenderer(renderOptions?: RenderOptions): Promise<VDomRenderer>;
    /** Displays the browser's printing dialog.
     * @param renderOptions  Specifies the rendering options.
     * @param onProgress  Callback for printing progress notifications.
     * @param checkCancel  Allows to cancel report printing.
     */
    print(renderOptions?: RenderOptions, onProgress?: (pageCount: number) => void, checkCancel?: () => boolean): Promise<void>;
}
declare type PageInfo = {
    PageWidth: string;
    PageHeight: string;
    LeftMargin: string;
    RightMargin: string;
    TopMargin: string;
    BottomMargin: string;
};
/** PageReport class */
declare class PageReport {
    readonly viewSettings: ViewSettings;
    private readonly i18n;
    private readonly webResourceProvider;
    /**
     * Create new instance of {@link PageReport} class.
     * @param options pageReport options
     * 	- language: report language. Default language is 'en'.
     */
    constructor(options?: Partial<{
        i18n: i18n;
        language: string;
        memoizeData: boolean;
    }>);
    /*Gets the report name. */
    readonly name: string;
    /*@deprecated Gets the report parameters collection. */
    readonly parameters: {
        readonly [name: string]: Parameter;
    };
    /*Gets the report parameters api. */
    readonly reportParameters: ReportParameters;
    /*Gets the report resource locator instance. */
    readonly resourceLocator: ResourceLocator;
    /*@deprecated Use setLicenseKey method instead. */
    static LicenseKey: string;
    private _instance;
    private _parameters;
    private _context;
    /** Loads the report template.
     * @param report  URI or the report template or template object.
     * @param options  Execution time settings.
     */
    load(report: string | Rdl.Report, options?: {
        environment?: Environment;
        resourceLocator?: Partial<ResourceLocator>;
        reportParameters?: {
            Name: string;
            Value: ParameterVariant[];
        }[];
    }): Promise<void>;
    /**
     * @deprecated use "reportsParameters.validate()" instead.
     * Validates the parameter values.
     * @returns Validation result.
     */
    validateParameters(): ValidationResults;
    /** @hidden */
    execData(requiredParams: RequiredParametersDesc): Promise<{
        [name: string]: {
            validValues: any[];
            values: any;
        };
    }>;
    /**
     * @deprecated
     * @hidden
     */
    resolveParametersValues(requiredParams?: string[]): Promise<void>;
    /** Starts rendering the report. */
    run(): Promise<PageDocument>;
}
/** Defines report parameter */
declare type Parameter = {
    /** Parameter descriptor */
    descriptor: ParameterDescriptorEx;
    /** Valid values */
    validValues: ParameterValue[];
    /** _true_ if valid values list was loaded */
    isValidValuesLoaded: boolean;
    /** Parameter values */
    values: ParameterVariant[];
    /** Shows error message for invalid parameter values */
    errorMessage: string | null;
};
/** @module Core/Parameters */ /** */
/** Defines parameter data type. */
declare type ParameterDataType = "Boolean" | "String" | "Integer" | "Float" | "Date" | "DateTime";
/** Defines report parameter descriptor */
declare type ParameterDescriptor = {
    /** Parameter name */
    name: string;
    /** Parameter data type */
    dataType: ParameterDataType;
    /** For multivalue parameter special value to indicate that all available values are selected */
    selectAllValue?: any;
    /** Allow blank */
    allowBlank: boolean;
    /** Allow null */
    nullable: boolean;
    /** Parameter is multivalue */
    multiValue: boolean;
    /** Parameters on which parameter depends */
    dependsOn: string[];
    /** Format to display value */
    displayFormat: string;
};
/**
 * Parameter visual presentation settings.
 */
declare type ParameterDescriptorConfig = {
    /** Indicates that parameter is hidden. Hidden parameters are not visible in parameter panel. */
    hidden: boolean;
    /** Parameter value prompt. */
    prompt: string;
    /** Multiline. */
    multiline: boolean;
};
/**
 * Parameter descriptor.
 */
declare type ParameterDescriptorEx = ParameterDescriptor & ParameterDescriptorConfig;
/** Defines parameter state */
declare type ParameterState = {
    values: ParameterVariant[];
    validValues: {
        loaded: true;
        values: {
            value: ParameterVariant;
            label: ParameterVariant;
        }[];
    } | {
        loaded: false;
    };
    status: {
        isValid: true;
    } | {
        isValid: false;
        error: string;
    };
};
/** @hidden */
declare enum ParameterStatus {
    ok = 0,
    expectValue = 1,
    hasOutstandingDependencies = 2,
    validationFailed = 3,
    dynamicValuesUnavailable = 4,
    communicating = 5,
    isValidation = 6
}
/**
 * Defines parameter value
 */
declare type ParameterValue = {
    /** Label to display */
    label: string;
    /** Value */
    value: ParameterVariant;
    /** Additional fields for extended parameter view */
    fields?: any[];
};
/** Type of parameter value */
declare type ParameterVariant = string | number | boolean | Date | null | NoValueType | SelectAllType;
declare type PostRequestInfo = {
    uri: string;
    method: "post";
    credentials?: "include";
    headers?: Record<string, string>;
    body?: any;
};
declare namespace rdlxparams_d {
    export { rdlxparams_d_ParameterStatus as ParameterStatus, rdlxparams_d_ParameterVariant as ParameterVariant, rdlxparams_d_GetValuesResult as GetValuesResult, };
}
type rdlxparams_d_GetValuesResult = GetValuesResult;
type rdlxparams_d_ParameterStatus = ParameterStatus;
declare const rdlxparams_d_ParameterStatus: typeof ParameterStatus;
type rdlxparams_d_ParameterVariant = ParameterVariant;
/** @hidden */
declare function readDataRecords(dataSource: Rdl.DataSource, dataSet: Rdl.DataSet, getResourceUri: (resourceID: string) => string, webResProvider?: WebResourceProvider): Promise<DataFieldsRecords | null>;
/**
 * @deprecated Use FontStore.registerFonts instead
 * Registers and loads user-specified fonts
 * @param fonts Set of font descriptors to be registered
 * @returns Promise that will be resolved when all fonts are loaded and ready for render
 */
declare function registerFont(...fonts: FontDescriptor[]): Promise<void>;
declare type RendererOptions = {
    TableStaticHeaders: boolean;
};
/** Document render options */
declare type RenderOptions = {
    /** Renders document without splitting the big content to pages. */
    galleyMode: boolean;
    /** Holds sorts/toggles state of the document. */
    interactivityActions: Array<{
        Type: "toggle";
        Data: string;
    } | {
        Type: "sort";
        Data: string;
    }>;
};
/** Defines report parameters */
declare type ReportParameters = {
    /**
     * Applies parameters values defined by steps
     * @param steps definitions of apply parameter steps
     */
    applySteps(steps: ApplyParameterStep[]): Promise<void>;
    /**
     * @deprecated Validates the parameter values.
     * @returns Validation result.
     */
    validate(): ValidationResults;
    /**
     * Returns parameters values for ParametersView.
     * @param knownValues Known parameters values.
     * @param requiredParameters Required parameters.
     */
    getValuesFor(knownValues: {
        [name: string]: ParameterVariant | ParameterVariant[];
    }, requiredParameters: {
        [name: string]: {
            fields: string[];
        } | null;
    }): Promise<GetValuesResult>;
    /**
     * Returns current parameters values.
     */
    getValues(): {
        [name: string]: ParameterState;
    };
    /**
     * Returns parameters descriptors.
     */
    getDescriptors(): {
        [name: string]: ParameterDescriptorEx;
    };
};
/** @hidden */
declare type RequiredParametersDesc = Record<string, {
    fields: string[];
} | null>;
/**
 * Definition of reset parameter step.
 */
declare type ResetParameterStep = {
    /**
     * The name of the parameter to be affected.
     */
    Name: string;
    /**
     * Parameter update type.
     */
    Type: "Reset";
};
declare type ResolvedStyle = {
    [propName: string]: string;
};
/**
 * Provide tools for accessing external resources by URIs.
 */
declare type ResourceLocator = {
    /**
     * Returns resource content.
     */
    getResource: <T>(uri: string) => Promise<T | null>;
    /**
     * Returns absolute resource URI based on relative ID and base path.
     */
    getResourceUri: (resourceID: string) => string;
    /**
     * Creates new ResourceLocator instance based on current one base path.
     * @param reportName Relative path for new report.
     */
    fork(reportName: string): ResourceLocator;
};
declare type Result<TR, TErr> = Success<TR> | Failure<TErr>;
/**
 * Defines the layout result type (for covariance).
 *
 * @typeparam TR
 */
declare type Result$1<TR> = {
    /** Gets the slice size. */
    Size: number;
    /** Gets the slice content. */
    Body: TR | null;
    /** Gets the slice tail. */
    Tail: LFunc<TR> | null;
    /** Gets true if layout failed. */
    IsFailed(): boolean;
    /**
     * Gets true is layout succeeded and there's a continuation.
     * Also returns true in case PageBreakBefore but not PageBreakAfter.
     */
    IsSplit(): boolean;
    /**
     *  Gets true is layout succeeded and there's no reminder (or reminder is zero).
     *  Explicitly check IsPageBreak result to detect latter case.
     */
    IsCompleted(): boolean;
    /**
     * Gets true the result is page break i.e. body is zero and there's a reminder.
     */
    IsPageBreak(): boolean;
    /**
    *  Gets true the slice succeeded (split) while the tail is zero layout.
    */
    IsPageBreakAfter(): boolean;
    /**
    *  Gets true if body is not empty
    */
    IsEmpty(): boolean;
};
/** @hidden */
declare type RunLayout = (rendererOptions: RendererOptions) => {
    L: Layout<VNode>;
    PageSize: SectionPageSize;
    ReportSectionDisplayName: string;
}[];
/** Scalar value. */
declare type ScalarValue = string | number | boolean | Date | null;
declare type ScopeSortState = {
    [ExpressionScope: string]: ExprScopeSortState;
};
/** @hidden */
declare type SearchOptions = {
    PageIndex: number;
    ItemIndex: number;
    Text: string;
    MatchCase: boolean;
    WholeWord: boolean;
    SearchBackward: boolean;
};
declare type SearchResult = {
    id: string;
};
declare type SectionPageSize = {
    PageWidth: string;
    PageHeight: string;
    RightMargin: string;
    LeftMargin: string;
    TopMargin: string;
    BottomMargin: string;
};
/** Special value for multivalue parameter to indicate that all values are set. */
declare const selectAll: SelectAllType;
/** Defines special value for multivalue parameter to indicate that all values are set. */
declare type SelectAllType = {
    /** @hidden */
    selectAll: "$selectAll";
};
/**
 * Set ARJS license key
 * @param key license key value
 */
declare function setLicenseKey(key: string): void;
/**
 * Definition of set parameter step.
 */
declare type SetParameterStep = {
    /**
     * The name of the parameter to be affected.
     */
    Name: string;
    /**
     * Parameter value to set.
     */
    Value: VariantValue;
    /**
     * Parameter update type.
     */
    Type: "Set";
};
declare type SortState = {
    [ScopeId: number]: ScopeSortState;
};
declare type StaticStyle = {
    className: string;
    style: ResolvedStyle;
};
declare type Success<TR> = {
    kind: "success";
    value: TR;
};
declare type ToggleAction = {
    Type: "toggle";
    ScopeId: number;
    ItemPath: Array<string>;
};
/**
 * Definition of toggle parameter step.
 */
declare type ToggleParameterStep = {
    /**
     * The name of the parameter to be affected.
     */
    Name: string;
    /**
     * Parameter value to toggle.
     */
    Value: VariantValue;
    /**
     * Parameter update type.
     */
    Type: "Toggle";
};
/** Unsubscribe event handler */
declare type UnregisterHandler = () => void;
/**
 * User defined function for using in report expressions
 */
declare type UserDefinedFunction = {
    name: string;
    body: (...args: any[]) => any;
    info?: {
        description?: string;
        example?: string;
        syntax?: string;
    };
};
/** Parameter validation result */
declare type ValidationResult = {
    /** Indicates whether validation success or not. */
    isValid: boolean;
    /** New validated parameter value. */
    value?: any;
    /** The error text in case of validation fails. */
    message?: string;
};
/** Parameters validation result */
declare type ValidationResults = {
    /** Dictionary with validation results per parameter */
    [parameter: string]: ValidationResult;
};
//# sourceMappingURL=expressionNode.d.ts.map
declare type VariantType = "Null" | "Bool" | "Int32" | "Int64" | "UInt64" | "Float" | "Double" | "Decimal" | "TimeSpan" | "Date" | "String" | "Enum" | "Object";
/** Variant Value. Can be used as parameter value. */
declare type VariantValue = ScalarValue | ScalarValue[] | {
    [index: string]: ScalarValue;
};
/** @hidden */
declare class VDomRenderer {
    private readonly documentMapFn;
    private readonly styles;
    private readonly galleyMode;
    private readonly i18n?;
    static create(pageDoc: PageDocument, renderOptions?: RenderOptions, i18n?: i18n): Promise<VDomRenderer>;
    static renderToDOM(content: VNode, patches?: NodePatch[][], options?: DOMRenderingOptions): HTMLElement;
    static getCssString(style: ResolvedStyle): string;
    private readonly language;
    private readonly pageGenerator;
    private readonly pages;
    private readonly patches;
    private readonly tocLabels;
    private constructor();
    render(): IterableIterator<{
        pageCount: number;
        isComplete: boolean;
    }>;
    getPage(pIndex: number): VNode | null;
    getDelayedContent(pageIndex: number): NodePatch[][] | null;
    getDocumentMap(): {
        kids: DocumentMapNode[];
    };
    resolveBookmark(label: string): number | null;
    getContent(): {
        pages: VNode[];
        patches: NodePatch[][][];
        styles: StaticStyle[];
    };
    findText(options: SearchOptions): IterableIterator<{
        text: string;
        itemId: string;
        pageIndex: number;
        itemIndex: number;
        position: number;
        length: number;
    }>;
    print(onProgress?: (pageCount: number) => void, checkCancel?: () => boolean): Promise<void>;
    getFontFaces(): string;
    private _e;
}
/** @hidden */
declare const Version: string;
/**
 * Viewer settigs for report.
 */
declare type ViewSettings = {
    /** List of document view types. */
    restrictViewTypes: ViewType[];
    /** JSON string representing parameters view settings */
    parametersView?: string;
};
/**
 * Document view type.
 *  PrintLayout:
 *    View document ready for print - with page sizes defined in definition.
 *  Galley:
 *    View document as web page - page sizes are ignored and document takes required space.
 *  Pageless:
 *    View pageless document that supports scrollable report items and multiple sections.
 */
declare type ViewType = "PrintLayout" | "Galley" | "Pageless";
declare type WebError = {
    status?: number;
    message: string;
};
declare type WebRequestInfo = GetRequestInfo | PostRequestInfo;
declare type WebResourceProvider = DataResourceProvider<WebRequestInfo, WebError>;
/** @hidden */
declare const withLocalizedErrors: (i18n: WithT) => <U extends any[], TR>(fn: (...args: U) => TR) => (...args: U) => TR;
/** @hidden */
declare const withLocalizedErrorsAsync: (i18n: WithT) => <U extends any[], TR>(fn: (...args: U) => Promise<TR>) => (...args: U) => Promise<TR>;
export { Rdl };
export { CultureInfo, CustomCode, Environment, Event, EventHandler, FontDescriptor, FontStore, NoValueType, PageDocument, PageReport, Parameter, ParameterDataType, ParameterDescriptor, ParameterDescriptorConfig, ParameterDescriptorEx, ParameterValue, ParameterVariant, RenderOptions, ReportParameters, ResourceLocator, SelectAllType, UnregisterHandler, VDomRenderer, ValidationResult, ValidationResults, Version, arjsStyles, getLicenseKey, noValue, rdlxparams_d as rdlxParams, readDataRecords, registerFont, selectAll, setLicenseKey, withLocalizedErrors, withLocalizedErrorsAsync };
